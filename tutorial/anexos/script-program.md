# üöÄ Script Program - Explicaci√≥n L√≠nea por L√≠nea

> **üéØ Objetivo:** Entender completamente c√≥mo funciona el script `program`
> **üìã Nivel:** Intermedio - para estudiantes que quieren personalizar o crear scripts similares

## üìú **Script Completo con Documentaci√≥n**

```bash
#!/bin/bash
# ‚Üë Shebang: Le dice al sistema que use bash para ejecutar este script

# ===============================================
# SCRIPT DE PROGRAMACI√ìN AUTOM√ÅTICA ATMEGA328P
# ===============================================
# Prop√≥sito: Compilar y programar archivos .asm con un solo comando
# Uso: ./program archivo.asm  O  ./program archivo
# Autor: Tutorial ATmega328P Mac

# ===============================================
# CONFIGURACI√ìN PRINCIPAL
# ===============================================

# Tipo de microcontrolador objetivo
MCU="atmega328p"

# Tipo de programador para Xplain Mini
PROGRAMMER="xplainedmini"

# Puerto de comunicaci√≥n (usb para Xplain Mini)
PORT="usb"

# ===============================================
# C√ìDIGOS DE COLOR PARA OUTPUT BONITO
# ===============================================
# Estos c√≥digos hacen que el texto tenga colores en terminal

GREEN='\033[0;32m'      # Verde para √©xito ‚úÖ
RED='\033[0;31m'        # Rojo para errores ‚ùå
YELLOW='\033[1;33m'     # Amarillo para procesos ‚ö†Ô∏è
BLUE='\033[0;34m'       # Azul para informaci√≥n ‚ÑπÔ∏è
NC='\033[0m'            # No Color - resetea a color normal

# ===============================================
# FUNCI√ìN: MOSTRAR AYUDA
# ===============================================
show_help() {
    # echo -e permite usar c√≥digos de color (\033)
    echo -e "${GREEN}üöÄ Script de programaci√≥n autom√°tica para ATmega328P${NC}"
    echo -e "${YELLOW}üìã Uso:${NC}"
    echo "  ./program archivo.asm     - Programa archivo.asm"
    echo "  ./program archivo         - Programa archivo.asm (agrega .asm autom√°ticamente)"
    echo "  ./program -h              - Esta ayuda"
    echo ""
    echo -e "${YELLOW}üí° Ejemplos:${NC}"
    echo "  ./program simple_blink    - Compila y programa simple_blink.asm"
    echo "  ./program main.asm        - Compila y programa main.asm"
}

# ===============================================
# FUNCI√ìN: SALIR CON ERROR
# ===============================================
error_exit() {
    # $1 es el primer argumento pasado a la funci√≥n
    echo -e "${RED}‚ùå Error: $1${NC}" >&2  # >&2 env√≠a a stderr en lugar de stdout
    exit 1  # Salir del script con c√≥digo de error 1
}

# ===============================================
# FUNCI√ìN: PROGRAMAR MICROCONTROLADOR
# ===============================================
program_chip() {
    local hex_file="$1"  # local hace que la variable solo exista en esta funci√≥n

    echo -e "${YELLOW}üöÄ Programando ATmega328P via Xplain Mini...${NC}"
    echo -e "${BLUE}‚ÑπÔ∏è  Aseg√∫rate de que la Xplain Mini est√© conectada${NC}"

    # Ejecutar avrdude y capturar si falla
    avrdude -c "$PROGRAMMER" -p "$MCU" -P "$PORT" -U flash:w:"$hex_file":i || error_exit "Error programando el chip"

    echo -e "${GREEN}‚úÖ Programaci√≥n exitosa!${NC}"
}

# ===============================================
# PROGRAMA PRINCIPAL - EMPIEZA AQU√ç
# ===============================================

# -----------------------------------------------
# VERIFICAR ARGUMENTOS DE ENTRADA
# -----------------------------------------------

# $# contiene el n√∫mero de argumentos pasados al script
if [ $# -eq 0 ]; then
    # No hay argumentos, mostrar error
    echo -e "${RED}‚ùå Error: Falta el nombre del archivo${NC}"
    echo ""
    show_help
    exit 1
fi

# -----------------------------------------------
# MANEJAR SOLICITUDES DE AYUDA
# -----------------------------------------------

# $1 es el primer argumento
if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    show_help
    exit 0  # Salir exitosamente (c√≥digo 0)
fi

# -----------------------------------------------
# PROCESAR NOMBRE DEL ARCHIVO CON ESTRUCTURA PROFESIONAL
# -----------------------------------------------

# Obtener el archivo especificado
FILE="$1"

# Agregar extensi√≥n .asm si no la tiene
# [[ ]] es test avanzado de bash
# != significa "no igual a"
# *.asm es patr√≥n que significa "termina en .asm"
if [[ "$FILE" != *.asm ]]; then
    FILE="${FILE}.asm"  # ${variable}.extension agrega la extensi√≥n
fi

# -----------------------------------------------
# L√ìGICA INTELIGENTE DE B√öSQUEDA DE ARCHIVOS
# -----------------------------------------------
# El script busca el archivo en m√∫ltiples ubicaciones:
# 1. Directorio actual (compatibilidad con proyectos antiguos)
# 2. Carpeta src/ (estructura profesional nueva)

SOURCE_FILE=""  # Variable para almacenar ruta encontrada

# Buscar primero en src/ (estructura preferida)
if [ -f "src/$FILE" ]; then
    SOURCE_FILE="src/$FILE"
    echo -e "${BLUE}‚ÑπÔ∏è  Archivo encontrado en estructura profesional: src/$FILE${NC}"

# Si no est√° en src/, buscar en directorio actual (compatibilidad)
elif [ -f "$FILE" ]; then
    SOURCE_FILE="$FILE"
    echo -e "${YELLOW}‚ö†Ô∏è  Archivo encontrado en directorio actual: $FILE${NC}"
    echo -e "${BLUE}üí° Sugerencia: Considera mover archivos .asm a carpeta src/${NC}"

# Si no se encuentra en ning√∫n lado, mostrar error informativo
else
    echo -e "${RED}‚ùå Error: Archivo '$FILE' no encontrado${NC}"
    echo -e "${YELLOW}üîç Ubicaciones buscadas:${NC}"
    echo -e "   üìÅ src/$FILE   (estructura profesional)"
    echo -e "   üìÑ $FILE       (directorio actual)"
    echo ""
    echo -e "${BLUE}üí° Tips:${NC}"
    echo -e "   ‚Ä¢ Crea carpeta 'src' y mueve archivos .asm ah√≠"
    echo -e "   ‚Ä¢ Verifica que el archivo existe y tiene extensi√≥n .asm"
    exit 1
fi

# -----------------------------------------------
# CREAR DIRECTORIO build/ PARA ARCHIVOS GENERADOS
# -----------------------------------------------
# Mantener el proyecto limpio separando archivos fuente de generados

BUILD_DIR="build"

# Crear directorio build/ si no existe
# -p hace que no d√© error si ya existe
if [ ! -d "$BUILD_DIR" ]; then
    echo -e "${BLUE}üìÅ Creando directorio build/ para archivos generados...${NC}"
    mkdir -p "$BUILD_DIR"
fi

# -----------------------------------------------
# MOSTRAR INFORMACI√ìN DEL PROCESO
# -----------------------------------------------

echo -e "${GREEN}üéØ Procesando archivo: $SOURCE_FILE${NC}"

# Obtener nombre base sin extensi√≥n para archivos generados
# $(basename file .ext) quita el path y la extensi√≥n
BASENAME=$(basename "$SOURCE_FILE" .asm)

echo -e "${YELLOW}üì¶ Compilando $SOURCE_FILE...${NC}"

# ===============================================
# PROCESO DE COMPILACI√ìN PASO A PASO
# ===============================================

# -----------------------------------------------
# PASO 1: COMPILAR ASSEMBLY A OBJETO
# -----------------------------------------------
# avr-gcc compila c√≥digo Assembly a archivo objeto (.o)

avr-gcc -mmcu="$MCU" \              # Especificar microcontrolador
        -I. \                       # Incluir archivos del directorio actual
        -x assembler-with-cpp \     # Tratar como Assembly con preprocesador
        -g \                        # Incluir informaci√≥n de debug
        -c "$SOURCE_FILE" \         # Compilar archivo fuente encontrado
        -o "$BUILD_DIR/${BASENAME}.o" # Archivo objeto va a build/

# || significa "o" - si el comando anterior falla, ejecutar error_exit
|| error_exit "Error en compilaci√≥n"

# -----------------------------------------------
# PASO 2: ENLAZAR OBJETO A EJECUTABLE
# -----------------------------------------------
# avr-gcc enlaza archivos objeto para crear ejecutable (.elf)

avr-gcc -mmcu="$MCU" \                  # Especificar microcontrolador
        "$BUILD_DIR/${BASENAME}.o" \    # Archivo objeto de build/
        -o "$BUILD_DIR/${BASENAME}.elf" # Archivo ejecutable a build/

|| error_exit "Error en enlazado"

# -----------------------------------------------
# PASO 3: CREAR ARCHIVO HEX PARA PROGRAMAR
# -----------------------------------------------
# avr-objcopy convierte ELF a formato HEX que entiende avrdude

avr-objcopy -j .text \                  # Incluir secci√≥n de c√≥digo
            -j .data \                  # Incluir secci√≥n de datos
            -O ihex \                   # Formato de salida Intel HEX
            "$BUILD_DIR/${BASENAME}.elf" \ # Archivo ELF de build/
            "$BUILD_DIR/${BASENAME}.hex"   # Archivo HEX a build/

|| error_exit "Error creando HEX"

# -----------------------------------------------
# MOSTRAR TAMA√ëO DEL PROGRAMA
# -----------------------------------------------

echo -e "${BLUE}üìè Tama√±o del programa:${NC}"

# avr-size muestra cu√°nta memoria usa el programa
avr-size --format=avr \                 # Formato espec√≠fico para AVR
         --mcu="$MCU" \                 # Especificar microcontrolador
         "$BUILD_DIR/${BASENAME}.elf"   # Archivo ELF de build/

echo -e "${GREEN}‚úÖ Compilaci√≥n exitosa: build/${BASENAME}.hex${NC}"

# ===============================================
# PROCESO DE PROGRAMACI√ìN
# ===============================================

# Llamar a la funci√≥n program_chip con el archivo HEX del directorio build/
program_chip "$BUILD_DIR/${BASENAME}.hex"

# -----------------------------------------------
# MENSAJES FINALES DE √âXITO
# -----------------------------------------------

echo -e "${GREEN}üéâ ¬°Proceso completado exitosamente!${NC}"
echo -e "${BLUE}üí° Tu c√≥digo est√° ahora ejecut√°ndose en el ATmega328P${NC}"

# ===============================================
# FIN DEL SCRIPT
# ===============================================
# El script termina aqu√≠ exitosamente
```

---

## üîç **Explicaci√≥n de Conceptos**

### üîß **¬øQu√© es un Script Bash?**

Un **script bash** es un programa escrito en lenguaje shell que automatiza tareas. Est√° compuesto por:

- **Comandos**: Instrucciones que se ejecutan secuencialmente
- **Variables**: Almacenan valores (`MCU="atmega328p"`)
- **Funciones**: Bloques de c√≥digo reutilizable (`show_help()`)
- **Condicionales**: Decisiones (`if [ condici√≥n ]; then`)
- **Manejo de errores**: Qu√© hacer si algo falla (`|| error_exit`)

### üìã **Variables Importantes**

| Variable | Significado | Valor |
|----------|-------------|-------|
| `$0` | Nombre del script | `./program` |
| `$1, $2, ...` | Argumentos pasados | `simple_blink.asm` |
| `$#` | N√∫mero de argumentos | `1` |
| `$?` | C√≥digo de salida del √∫ltimo comando | `0` (√©xito) o `>0` (error) |

### üé® **C√≥digos de Color**

```bash
# Definici√≥n de colores
RED='\033[0;31m'        # Rojo
GREEN='\033[0;32m'      # Verde
YELLOW='\033[1;33m'     # Amarillo
BLUE='\033[0;34m'       # Azul
NC='\033[0m'            # No Color (reset)

# Uso en echo
echo -e "${GREEN}Texto en verde${NC}"
```

### üîß **Operadores de Test**

| Operador | Significado | Ejemplo |
|----------|-------------|---------|
| `-f archivo` | ¬øArchivo existe? | `[ -f "test.asm" ]` |
| `-d directorio` | ¬øDirectorio existe? | `[ -d "/home" ]` |
| `==` | ¬øSon iguales? | `[ "$var" == "valor" ]` |
| `!=` | ¬øSon diferentes? | `[ "$var" != "otro" ]` |
| `-z string` | ¬øString vac√≠o? | `[ -z "$var" ]` |

---

## üõ†Ô∏è **Personalizar el Script**

### üîß **Cambiar microcontrolador:**

```bash
# Para ATmega168
MCU="atmega168"

# Para ATmega32u4
MCU="atmega32u4"
```

### üîß **Agregar soporte para Arduino:**

```bash
# Agregar esta funci√≥n despu√©s de program_chip
program_arduino() {
    local hex_file="$1"

    # Buscar puerto Arduino autom√°ticamente
    PORT=$(ls /dev/cu.usbserial* /dev/cu.usbmodem* 2>/dev/null | head -1)

    if [ -z "$PORT" ]; then
        error_exit "No se encontr√≥ puerto Arduino"
    fi

    echo -e "${YELLOW}üöÄ Programando via Arduino en $PORT...${NC}"
    avrdude -c arduino -p "$MCU" -P "$PORT" -b 115200 -U flash:w:"$hex_file":i || error_exit "Error programando Arduino"
}

# Y modificar el main para detectar tipo de hardware
```

### üîß **Agregar verificaci√≥n de herramientas:**

```bash
# Agregar al inicio del script, despu√©s de las variables
check_tools() {
    echo -e "${YELLOW}üîç Verificando herramientas...${NC}"

    # Verificar que avr-gcc est√° instalado
    which avr-gcc >/dev/null || error_exit "avr-gcc no encontrado. Instalar con: brew install avr-gcc"

    # Verificar que avrdude est√° instalado
    which avrdude >/dev/null || error_exit "avrdude no encontrado. Instalar con: brew install avrdude"

    # Verificar que avr-objcopy est√° instalado
    which avr-objcopy >/dev/null || error_exit "avr-objcopy no encontrado"

    echo -e "${GREEN}‚úÖ Todas las herramientas disponibles${NC}"
}

# Llamar la funci√≥n en el main
check_tools
```

### üîß **Agregar modo verbose:**

```bash
# Agregar variable de configuraci√≥n
VERBOSE=false

# Modificar funci√≥n para mostrar m√°s detalles
if [ "$VERBOSE" = true ]; then
    echo -e "${BLUE}üîß Ejecutando: avr-gcc -mmcu=$MCU -I. -x assembler-with-cpp -g -c $FILE -o ${BASENAME}.o${NC}"
fi
```

### üîß **Soporte para m√∫ltiples archivos:**

```bash
# Modificar para aceptar m√∫ltiples archivos
if [ $# -eq 0 ]; then
    error_exit "Falta el nombre del archivo"
fi

# Procesar cada archivo
for FILE in "$@"; do
    echo -e "${GREEN}üéØ Procesando archivo: $FILE${NC}"
    # ... resto del proceso de compilaci√≥n
done
```

---

## üí° **Tips Avanzados**

### üîç **Debugging del Script:**

```bash
# Ejecutar script con debug info
bash -x ./program simple_blink.asm

# Agregar prints de debug
echo "DEBUG: FILE=$FILE, BASENAME=$BASENAME"

# Verificar variables
set -x  # Activar debug mode
set +x  # Desactivar debug mode
```

### ‚ö° **Optimizaci√≥n de Velocidad:**

```bash
# Compilar en paralelo (si tienes m√∫ltiples archivos)
avr-gcc ... & avr-objcopy ... &
wait  # Esperar a que terminen todos los procesos paralelos

# Cach√© de archivos compilados
if [ "${BASENAME}.hex" -ot "$FILE" ]; then
    echo "Archivo ya est√° actualizado, saltando compilaci√≥n"
    program_chip "${BASENAME}.hex"
    exit 0
fi
```

### üîß **Manejo Avanzado de Errores:**

```bash
# Trap para limpiar archivos temporales si el script falla
cleanup() {
    echo -e "${YELLOW}üßπ Limpiando archivos temporales...${NC}"
    rm -f *.o temp_*
}
trap cleanup EXIT

# Logging de errores
log_error() {
    echo "$(date): $1" >> error.log
    error_exit "$1"
}
```

---

## üìñ **Versi√≥n Simplificada para Principiantes**

Si el script completo es muy complejo, aqu√≠ hay una versi√≥n b√°sica:

```bash
#!/bin/bash

# Script b√°sico para programar ATmega328P
FILE="$1"

# Agregar .asm si no tiene extensi√≥n
[[ "$FILE" != *.asm ]] && FILE="${FILE}.asm"

# Verificar que existe
[ ! -f "$FILE" ] && echo "‚ùå Archivo no encontrado" && exit 1

# Obtener nombre base
BASENAME=$(basename "$FILE" .asm)

# Compilar
echo "üì¶ Compilando..."
avr-gcc -mmcu=atmega328p -x assembler-with-cpp -c "$FILE" -o "${BASENAME}.o" || exit 1
avr-gcc -mmcu=atmega328p "${BASENAME}.o" -o "${BASENAME}.elf" || exit 1
avr-objcopy -O ihex "${BASENAME}.elf" "${BASENAME}.hex" || exit 1

# Programar
echo "üöÄ Programando..."
avrdude -c xplainedmini -p atmega328p -P usb -U flash:w:"${BASENAME}.hex":i || exit 1

echo "‚úÖ ¬°Completado!"
```

---

## üöÄ **Scripts Relacionados √ötiles**

### üîß **Script para limpiar archivos:**

```bash
#!/bin/bash
# cleanup.sh - Limpiar archivos generados

echo "üßπ Limpiando archivos..."
rm -f *.o *.elf *.hex *.lst
echo "‚úÖ Limpieza completa"
```

### üîß **Script para ver tama√±o de todos los programas:**

```bash
#!/bin/bash
# sizes.sh - Ver tama√±o de todos los programas

echo "üìè Tama√±os de programas:"
for hex in *.hex; do
    if [ -f "$hex" ]; then
        elf="${hex%.hex}.elf"
        if [ -f "$elf" ]; then
            echo "=== $hex ==="
            avr-size --format=avr --mcu=atmega328p "$elf"
        fi
    fi
done
```

## üìÅ **Ventajas de la Estructura src/build/**

### üéØ **¬øPor qu√© separar archivos fuente y generados?**

```
proyecto_profesional/
‚îú‚îÄ‚îÄ src/                     # üìù Solo c√≥digo que escribes
‚îÇ   ‚îú‚îÄ‚îÄ main.asm
‚îÇ   ‚îú‚îÄ‚îÄ blink.asm
‚îÇ   ‚îî‚îÄ‚îÄ utils.asm
‚îú‚îÄ‚îÄ build/                   # üîß Solo archivos generados
‚îÇ   ‚îú‚îÄ‚îÄ main.hex
‚îÇ   ‚îú‚îÄ‚îÄ main.elf
‚îÇ   ‚îî‚îÄ‚îÄ main.o
‚îú‚îÄ‚îÄ Makefile                 # ‚öôÔ∏è Automatizaci√≥n
‚îî‚îÄ‚îÄ program                  # üöÄ Este script
```

### ‚úÖ **Beneficios tangibles:**

1. **üóëÔ∏è Git m√°s limpio:** Solo hacer commit de `src/`, ignorar `build/`
2. **üßπ Mantenimiento f√°cil:** `rm -rf build/` limpia todo sin tocar c√≥digo
3. **üë• Trabajo en equipo:** Evita conflictos con archivos generados
4. **üéØ Foco:** Solo el c√≥digo fuente es importante de verdad
5. **üìè Proyectos escalables:** F√°cil agregar subdirectorios en `src/`

### üîß **El script se adapta autom√°ticamente:**

```bash
# ‚úÖ Encuentra archivo en cualquier estructura
./program blink              # Busca src/blink.asm, luego blink.asm

# ‚úÖ Crea build/ si no existe
# No necesitas hacer mkdir build/

# ‚úÖ Rutas inteligentes
# src/main.asm ‚Üí build/main.hex

# ‚úÖ Mensajes informativos
# Te dice d√≥nde encontr√≥ el archivo
```

### üöÄ **Comandos mejorados para la nueva estructura:**

```bash
# Ver estructura del proyecto
tree                         # macOS: brew install tree
# O con ls:
ls -la src/ build/

# Limpiar solo archivos generados (mantener fuentes)
rm -rf build/

# Buscar archivos fuente
find src/ -name "*.asm"

# Ver tama√±os de todos los proyectos
ls build/*.elf | xargs avr-size --format=avr --mcu=atmega328p
```

---

### üîß **Script para backup de proyectos:**

```bash
#!/bin/bash
# backup.sh - Crear backup del proyecto

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_NAME="proyecto_backup_$DATE.tar.gz"

echo "üíæ Creando backup..."
tar -czf "$BACKUP_NAME" *.asm *.h Makefile program README.md
echo "‚úÖ Backup creado: $BACKUP_NAME"
```

---

**üè† Regresar:** **[README.md](../README.md)**
**üìö Otros anexos:** **[anexos/](./)**
